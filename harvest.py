# -*- coding: latin-1 -*-
# ---------------------------------------------------------------------------
# harvest.py
# Created on: 2019-07-26 09:49:34.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: harvest <cosechas_cartografia__3_> <actas_liberadas__3_> 
# Description: 
# ---------------------------------------------------------------------------

# Import arcpy module
import arcpy
import os
import sys
import shutil
import tempfile
import numpy

import time
from   xlrd import open_workbook, cellname

global cws
import numpy as np

#---------------------------------------------------------
# eliminar SLIVERS
eliminarSliver = True
iso = 'latin-1'
global elDict
elDict ={}
#---------------------------------------------------------
eco = True # para tener un trazado de la ejecucion
#eco = False
#----------------------------------------------------------
# campons necesarios : nombre, tipo, largo
#-----------------------------------------------------------
camposNecesarios = [
    ['MES','SHORT',''],
    ['AGNO','SHORT',''],
    ['PCT_AVANCE','DOUBLE',''],
    ['AMES',"TEXT","6"]
    ]
cDissolve = ['TEMPORADA','ZONA','NUM_ACTA']
cDissolve1= ['TEMPORADA','ZONA','NUM_ACTA_1','CODIGO']
sCampos   = [['NUM_ACTA','COUNT'],['AREA','SUM']]
sCampos1  = [['AREA','SUM'],['SUM_AREA','FIRST']]

cCosNoRealizada=[
  ["ESTADO_ABC","LONG",'',0,'SI_ESTADO'],
  ["CAUSAL","LONG",'',0,'SI_CAUSAL' ],
  ["EQUIPO","LONG",'',0,'SI_EQUIPO'],
  ["OBS_CAUSAL","TEXT",'512','""',''],
  ["AREA_REMANENTE","DOUBLE",'','[SHAPE_AREA] / 10000','']
  ]

cAvanceGlobal=[["CODIGO","TEXT",'5','']]
                                  
mes = camposNecesarios[0][0]
agno= camposNecesarios[1][0]
pct = camposNecesarios[2][0]
ames= camposNecesarios[3][0]

scr,cartografia,actas, inter, ="","","",""
avanceD =""
intersect = "Avance_Cosecha"   # NOMBRE DEL INTERSECT = AVANCE_COSECHA
cfecha    = "FCH_TRAN"         # NOMBRE CAMPO DE LA FECHA DE LA ACTUALIZACION
has       = "AREA"             # CAMPO CON LA SUP EN HAS       
c1        = []
c2        = []
tmpDir    = r"c:\temp"         # DIRECTORIO TEMPORAL 
minArea   = "1000"             # metros2 = 0.1has
eps       = 0.1                # resolucion 10 cm

cwDefecto = r'C:\D\proyectos\2019\ARAUCO_CARTO\actasCosecha\CIERRE_COSECHA_v02.gdb'
cDefecto  = "cosechas_cartografia"
aDefecto  = "actas_liberadas"

NoPlanif  = 'Cosecha_NoPlanificada' # NOMBRE FC DE SALIDA
Remanente = 'Cosecha_NoRealizada'   # NOMBRE FC DE SALIDA

camposCierre = [['CERRADA','TEXT',1],
                ['SIP_XLSX','LONG',''],
                ['NOM_PREDIO','TEXT',35],
                ['MES','TEXT',10],
                ['AGNO','SHORT',''],
                ['TIPO','SHORT',''],
                ["CODIGO","TEXT",'5']
               ]


#------------------------------
def crearDominios(archExcel=""):
#------------------------------
  if eco:
    imprimir("Procesando DOMINIOS")
  if archExcel =="":
    arcExcel = archivoE
  if not os.path.exists(archExcel):
    return 
  dominios =['ESTADO','CAUSAL','EQUIPO']
  listaD = arcpy.da.ListDomains(arcpy.env.workspace)
  ll =[]
  for dn in listaD:
    ll.append(dn.name)
  for dm in dominios:
      x ="SI_"+dm
      if eco:
        imprimir("DOMINIO ="+x)
      if x in ll:
        pass
      else:
        try:
         arcpy.ExcelToTable_conversion(archExcel, "T_"+x, x)
         arcpy.TableToDomain_management("T_"+x,"CODIGO","DESCRIPCION",arcpy.env.workspace,x)
        except:
          imprimir("===> PROBLEMA PARA PROCESAR DOMINIO:"+x)
          pass
#------------------------------
def agregRemanente(fc):
#------------------------------
  lc = [f.name for f in arcpy.ListFields(fc)]
  if eco:
    imprimir("============> Agreg remananete "+fc)
    print(lc)
  for camp in cCosNoRealizada:
    if eco:
      imprimir(camp[0])
    if not(camp[0] in lc):
     if len(camp[2])>0:
       arcpy.AddField_management(fc,camp[0],camp[1],field_length=camp[2],field_domain=camp[4])
     else:
      arcpy.AddField_management(fc,camp[0],camp[1],field_domain=camp[4])
     if eco:
      imprimir(camp[0]+ "   "+str(camp[3]))
     arcpy.CalculateField_management(fc, camp[0],camp[3])
       

#------------------------------
def agregCosFinal(fc, camp, todo=True):
#------------------------------
  lc = [f.name for f in arcpy.ListFields(fc)]
  try:
     if eco:
          imprimir("AgregCosFinal "+fc)
     if camp[0][0] not in lc:
       arcpy.AddField_management(fc,camp[0][0],camp[0][1],field_length=camp[0][2])
     if todo:
       if camp[1][0] not in lc:
        arcpy.AddField_management(fc,camp[1][0],camp[1][1])
       if camp[2][0] not in lc:
        arcpy.AddField_management(fc,camp[2][0],camp[2][1],field_length=camp[2][2])
       if camp[3][0] not in lc:
        arcpy.AddField_management(fc,camp[3][0],camp[3][1],field_length=camp[3][2])
       if camp[4][0] not in lc:
        arcpy.AddField_management(fc,camp[4][0],camp[4][1])
       if camp[5][0] not in lc:
        arcpy.AddField_management(fc,camp[5][0],camp[5][1])
        #arcpy.AddField_management(fc,camp[6][0],camp[6][1],field_length=camp[6][2])
  except:
       pass
#------------------------------
def leerExcel(archivo=""):
#-----------------------------
     imprimir("Leyendo Excel...")
     iso ='latin-1'
     actas = {}
     finActas = int(time.strftime('%Y'))+1
     comienzoActas = finActas - 2

     if archivo =="":
        archivo = r"C:\D\proyectos\2019\ARAUCO_CARTO\PLANILLAS_ACTAS\Actas Cerradas_2019_S4_Julio.xlsx"
     if not os.path.isfile(archivo):                              # SI NO EXISTE SE CREA DIR TEMPORAL C:\TEMP
            imprimir("NO EXISTE EXCEL = "+archivo)
            return actas
     book = open_workbook(archivo) #abre el libro excel
     for j in range(comienzoActas, finActas):
         print("Procesando "+str(j))
         try:
             sheet = book.sheet_by_name(str(j))
             try:
              for row_index in range(1, sheet.nrows, 1):
                 cos  = sheet.cell(row_index,3).value
                 acta, zona, mes, sip, predio = -1, "","",-1,""
                 if cos.lower() == 'cosecha':
                    acta  = sheet.cell(row_index,0).value
                    zona  = sheet.cell(row_index,1).value
                    zona  = zona.encode(iso).decode(iso)
                    mes   = sheet.cell(row_index,2).value
                    sip   = sheet.cell(row_index,4).value
                    predio= sheet.cell(row_index,5).value
                    predio=predio.encode(iso).decode(iso)
                    actas[acta]= [zona,mes,j,sip,predio]
             except:
                  imprimir("Error en linea "+str(row_index)+ " Year ="+str(j))
         except:
             imprimir("Problemas abrir "+str(j))
     book.release_resources()
     del book
     imprimir("Diccionario Creado...")
     return actas

#------------------------------     
def imprimir(linea):
#------------------------------
    print(linea)
    arcpy.AddMessage(linea)
#------------------------------
def agregarHAS(fc, chas):
#------------------------------
    lista = [f.name for f in arcpy.ListFields(fc)]
    if not chas in lista:
        arcpy.AddField_management(fc, chas, "DOUBLE")
    arcpy.CalculateField_management(fc, chas, "[Shape_area] / 10000","VB","")

        
#------------------------------
def agregarCampos(fc,fecha):
#------------------------------
    lista = [f.name for f in arcpy.ListFields(fc)]
    if eco:
        imprimir("AGREGANDO CAMPOS EN "+fc)
        imprimir(lista)
        imprimir(fecha)
    if not (camposNecesarios[0][0] in lista):
           if eco:
             imprimir("AGREGANDO "+camposNecesarios[0][0])
           arcpy.AddField_management(fc,camposNecesarios[0][0],camposNecesarios[0][1])
    if not (camposNecesarios[1][0] in lista):
           if eco:
             imprimir("AGREGANDO "+camposNecesarios[1][0])
           arcpy.AddField_management(fc,camposNecesarios[1][0],camposNecesarios[1][1])
    if not (camposNecesarios[2][0] in lista):
           if eco:
             imprimir("AGREGANDO "+camposNecesarios[2][0])
           arcpy.AddField_management(fc,camposNecesarios[2][0],camposNecesarios[2][1])
    if not (camposNecesarios[3][0] in lista):
           if eco:
             imprimir("AGREGANDO "+camposNecesarios[3][0])
           arcpy.AddField_management(fc,camposNecesarios[3][0],camposNecesarios[3][1],field_length=camposNecesarios[3][2])
    if eco:
      imprimir("CALCULANDO MES="+mes)
    arcpy.CalculateField_management(fc,mes, "MONTH(["+fecha+"])", "VB", "")
    if eco:
      imprimir("CALCULANDO AGNO="+agno)
    arcpy.CalculateField_management(fc,agno, "YEAR(["+fecha+"])", "VB", "")
    if eco:
      imprimir("CALCULAANDO PCT ="+pct)
    if not (pct in lista):
      arcpy.AddField_management(fc,pct,'DOUBLE')
    arcpy.CalculateField_management(fc,pct, "100 * [AREA] / [AREA_1]", "VB", "")
    codeb = """def am(a,m):
     ca = str(a)
     mm = str(m)
     if len(mm) == 1:
        mm = '0'+mm
     return (ca + mm)"""
    
    ex1 = "am(!"+ agno +"!,!"+mes+"!)"
    arcpy.CalculateField_management(fc,ames, ex1 , "PYTHON_9.3", codeb)
#------------------------------------------
def elimina(objeto):
#------------------------------------------
    if arcpy.Exists(objeto):
        try:
          arcpy.Delete_management(objeto)
        except:
            imprimir("No pudo ser eliminado "+objeto)
#------------------------------------------
def etapa1(carto, actas, fecha, salida):
#------------------------------------------
    carto = cws + os.path.sep + carto
    actas =  actas.replace(cws + os.path.sep,"")
    
    arcpy.env.workspace = scr
    crearDominios(archivoE)
    arcpy.env.overwriteOutput = True

    if actas.find(":") == -1:
        actas =  cws+os.path.sep + actas
    avance = scr + os.path.sep + salida
    elimina(avance)
    if eco:
        imprimir("\nETAPA WORKSPACE SALIDA ==>"+ scr+"\nINTERSECCION  ==> AVANCE="+avance+"\nCampos MES,AGNO,AMES,PCT_AVANCE\n")
    
    arcpy.Intersect_analysis([carto, actas], avance, "ALL",eps, "INPUT")
    if fecha <> "":
       if eco:
         imprimir("AGREGAR CAMPOS CON "+avance+" fecha ="+fecha)
       agregarCampos(avance,fecha)    
    return avance
#------------------------------------------
def crearPoligonos(fc,salida):
#------------------------------------------
    if not arcpy.Exists(scr+os.path.sep+salida):
        if eco:
            imprimir("Creando ..."+salida)
        arcpy.CreateFeatureclass_management(scr, salida, 'POLYGON', template=fc,spatial_reference = fc)
    else:
        if eco:
            imprimir("Truncando ..."+salida)
        arcpy.TruncateTable_management(os.path.sep+salida)
#------------------------------------------ 
def crearSalidas(fc,nPlanif,nRealizada):
#------------------------------------------
    if eco:
        imprimir('\nETAPA 3.  NO COSECHADO & REMANENTE')
    crearPoligonos(fc, nPlanif)
    crearPoligonos(fc, nRealizada)
#------------------------------------------
def limpiaFinal():
#------------------------------------------
    arcpy.env.workspace = scr
    todel =['actas_liberadas0','Avance_Cosecha0']
    for fc in todel:
      if arcpy.Exists(fc):
        arcpy.Delete_management(fc)
        
#---------------------------------
def procesarAvance(actas):
#---------------------------------
    if eco:
      imprimir("+++++++++++++++++++++++++++++++++++")
      imprimir("  PROCESAR AVANCE")
    actas1 = actas
    if actas.find(":") == -1:
        actas1 = cws +  os.path.sep + actas

    dactas = actas+"0"
    arcpy.env.overwrite = True
    if arcpy.Exists(scr + os.path.sep + dactas):
        arcpy.Delete_management(scr + os.path.sep + dactas)
    if eco:
       imprimir(" A DISOLVER "+actas+ "-->"+ dactas)
       imprimir(cDissolve)
       imprimir(sCampos)
    #imprimir("primer dissolve ="+scr + os.path.sep + dactas)
    arcpy.Dissolve_management(actas1, scr + os.path.sep + dactas,cDissolve, sCampos)
    agregarHAS(scr + os.path.sep + dactas,"SUM_AREA")
    salida = etapa1(cartografia, scr + os.path.sep + dactas, "", intersect+"0")
    #imprimir("salida de etap1 ="+salida)
    agregarHAS(salida,"AREA")
    dactas1 = salida[0:len(salida)-1]+"_Global"
    
    if eco:
       imprimir(salida)
       imprimir(dactas1)
       imprimir("A DISOLVER "+salida+" --> "+dactas1)
       imprimir(cDissolve1)
       imprimir(sCampos1)
    if arcpy.Exists( dactas1):
       arcpy.Delete_management(dactas1)
    
    arcpy.Dissolve_management(salida,  dactas1,cDissolve1,sCampos1)
    arcpy.AddField_management(dactas1,camposNecesarios[2][0],camposNecesarios[2][1])
    arcpy.CalculateField_management(dactas1,pct, "100 * [SUM_AREA] / [FIRST_SUM_AREA]", "VB", "")
    agregCosFinal(dactas1, camposCierre)
    if eco:
      imprimir("FIN AVANCE ===================")
    return dactas1
#-------------------------------    
def lToc(mxd,fc,groupLayer=""):
#------------------------------
    df        = arcpy.mapping.ListDataFrames(mxd, "*")[0]
    addLayer = arcpy.mapping.Layer(fc)
    arcpy.mapping.AddLayer(df, addLayer, "BOTTOM")
#------------------------------------------    
def resumen(avanceDis):
#------------------------------------------
    imprimir("====================================================================================")
    imprimir("AVANCE COSECHA V1.6 -  CIERRE")
    imprimir("-------------------")
    imprimir("ESPACIO DE TRABAJO     = "+cws)
    imprimir("COSECHA CARTOGRAFICA   = "+cartografia)
    imprimir("COSECHA PLANIFICADA    = "+actas)
    imprimir(" ")
    imprimir("WORKSPACE SALIDA       = "+scr)
    imprimir("AVANCE COSECHA MENSUAL = "+intersect)
    imprimir("AVANCE COSECHA GLOBAL  = "+avanceDis.replace(scr+os.path.sep,""))
    if eliminarSliver:
        imprimir("Slivers eliminados con MinArea = "+minArea+" m2 or A/P < 0.25")
    imprimir("COSECHA NO PLANIFICADA = "+NoPlanif)
    imprimir("COSECHA NO REALIZADA   = "+Remanente)
    imprimir("CAMPO MES (ENTERO)     = COSECHA CARTOGRAFICA")
    imprimir("CAMPO AGNO(ENTERO)     = COSECHA CARTOGRAFICA")
    imprimir("CAMPO AMES(TEXTO)      = AGNO+MES COSECHA CARTOGRAFICA")
    imprimir("CAMPO PCT_AVANCE(DOBLE)= Porcentaje Avance==> 100 *(HAS CARTO COS/HAS PLANIFICADAS)")
    imprimir("====================================================================================")
    try:
        if eco:
          imprimir("LLEVANDO A LA TOC, DETECTANDO MXD")
        mxd = arcpy.mapping.MapDocument("CURRENT")
        if eco:
          imprimir("MXD DETECTADO")
        #eco = True
        if eco:
             imprimir("Actualizando Actas en No Planificado & No Realizado")
             imprimir(scr + os.path.sep + NoPlanif)
             imprimir(scr + os.path.sep + Remanente)
        if eco:
          imprimir("PROCESA NO con "+NoPlanif)
        procesaNO(scr + os.path.sep + NoPlanif,elDict,camposCierre)
        if eco:
          imprimir("LTOC con "+NoPlanif)
        lToc(mxd, scr + os.path.sep + NoPlanif)
        if eco:
          imprimir("PROCESA NO con "+Remanente)
        procesaNO(scr + os.path.sep + Remanente,elDict,camposCierre,"_1")
        if eco:
          imprimir("LTOC con "+Remanente)
        lToc(mxd, scr + os.path.sep + Remanente)

        #lToc(mxd, scr + os.path.sep + NoPlanif)
        #lToc(mxd, scr + os.path.sep + Remanente)
        if eco:
          imprimir("LTOC CON "+intersect)
        lToc(mxd, scr + os.path.sep + intersect)
        if eco:
          imprimir("LTOC CON "+avanceDis)
        # CALCULAR NOMBRE PREDIO DESDE ACTAS
        #imprimir("update cursor")

        actualizaGlobal(avanceDis,actas)      
        lToc(mxd, avanceDis)
        
    except:
        imprimir("No puedo cargar los resultados a TOC")

#
#------------------------------------------
def actualizaGlobal(avanceDis, actas):
#------------------------------------------
    try:
        if eco:
          imprimir("update "+avanceDis)
        with arcpy.da.UpdateCursor(avanceDis, ["CODIGO","NOM_PREDIO"]) as cur:
          if eco:
            imprimir("CURSOR UPDATE CREADO PARA "+avanceDis)
            
          for cod in cur:
            expresion = "CODIGO = '"+cod[0]+"'"
            nombre =""
            if eco:
              imprimir("Intentando crear Search cursor "+expresion+ " sobre "+actas)
            if not arcpy.Exists(actas):
                actas = cws + os.path.sep + actas
            
            with arcpy.da.SearchCursor(actas,["NOM_PREDIO"],where_clause=expresion) as cus:
              if eco:
                imprimir("Search Cursor creado sobre "+ actas)
              for nomb in cus:
                if eco:
                  imprimir("NOMBRE PREDIO ="+nomb[0])
                nombre=nomb[0]
            if eco:
                imprimir("nombre antes ="+str(cod[1]))
                imprimir("nombre nuevo ="+str(nombre))
            cod[1]=nombre
            if eco:
              imprimir("Update "+nombre)
            cur.updateRow(cod)
            if eco:
              imprimir("listo")
        del cus
        del cur
    except:
      a = arcpy.GetMessages()
      imprimir(str(a))
      imprimir("PROBLEMAS EN actualizaGLOBAL")

#---------------------------------------------
def procSli(fc, aMaxima, rarea=5, rper=5):
#---------------------------------------------
  aMaxima = float(aMaxima)
  lista = coordenadas(fc)
  sl=[]
  #
  init = lista[0][0]
  ar   = lista[0][2]
  h =[]
  k = 0
  while (k <= len(lista)-1):
      #print "---------------", k
      #print init, lista[k][0]  
      if init == lista[k][0]:
         h.append([lista[k][1][0], lista[k][1][1]])
         k = k + 1
      else:
        if ar <= aMaxima:
          sl.append(init)
        else:
         m = minBoundingRect(h)
         q = m[2] / m[3]
         if q < 1:
            q = 1 / q
         if (ar / m[1] > rarea) or q > rper:
             #print init,"SLIVER==>AREApOL, AREA RECT=", ar,m[1],"ancho,alto=", m[2],m[3]
             sl.append(init)
         else:
              #print init,"NO SLIVER",ar,m[1],"ancho,alto=", m[2],m[3]
              pass
        init = lista[k][0]
        h=[]
        ar = lista[k][2]
  if ar <= aMaxima:
          sl.append(init)
  else:
   m = minBoundingRect(h)
   q = m[2] / m[3]
   if q < 1:
            q = 1 / q
   if (ar / m[1] > rarea) or q > rper:
      #print init,"SLIVER==>AREApOL, AREA RECT=", ar,m[1],"ancho,alto=", m[2],m[3]
     sl.append(init)
   else:
     #print init,"NO SLIVER",ar,m[1],"ancho,alto=", m[2],m[3]
     pass
  return sl
#---------------------------------------------
def coordenadas(in_fc):
# PERMITE CREAR ARRAY CON TODOS LOS VERTICES DE
# TODOS LOS ELEMENTOS DE UN FC
#--------------------------------------------- 
    SR = arcpy.Describe(in_fc).spatialReference

    ##sdf = arcgis.SpatialDataFrame
    ##a_sdf = sdf.from_featureclass(in_fc,
    ##                            sql_clause=None,
    ##                            where_clause=None,
    ##                            sr=SR)
    ##a_rec = sdf.to_records(a_sdf)  # record array
    a_np = arcpy.da.FeatureClassToNumPyArray(in_fc,field_names=["OID@","SHAPE@XY","SHAPE_AREA"],spatial_reference=SR,explode_to_points=True)
    ##a_np2 = fc_g(in_fc)
    ##return sdf, a_sdf, a_rec, a_np, a_np2
    return a_np
#--------------------------------------------- 
def minBoundingRect(hull_points_2d):
# https://gist.github.com/sosukeinu/6aa923bed20bb499d1048bb084372af4
#--------------------------------------------- 
    #print "Input convex hull points: "
    #print hull_points_2d
    pRots = 0
    # Compute edges (x2-x1,y2-y1)
    edges = np.zeros( (len(hull_points_2d)-1,2) ) # empty 2 column array
    for i in range( len(edges) ):
        edge_x = hull_points_2d[i+1][0] - hull_points_2d[i][0]
        edge_y = hull_points_2d[i+1][1] - hull_points_2d[i][1]
        edges[i] = [edge_x,edge_y]
    #print "Edges: \n", edges

    # Calculate edge angles   atan2(y/x)
    edge_angles = np.zeros( (len(edges)) ) # empty 1 column array
    for i in range( len(edge_angles) ):
        edge_angles[i] = math.atan2( edges[i,1], edges[i,0] )
    #print "Edge angles: \n", edge_angles

    # Check for angles in 1st quadrant
    for i in range( len(edge_angles) ):
        edge_angles[i] = abs( edge_angles[i] % (math.pi/2) ) # want strictly positive answers
    #print "Edge angles in 1st Quadrant: \n", edge_angles

    # Remove duplicate angles
    edge_angles = np.unique(edge_angles)
    #print "Unique edge angles: \n", edge_angles

    # Test each angle to find bounding box with smallest area
    min_bbox = (0, sys.maxint, 0, 0, 0, 0, 0, 0) # rot_angle, area, width, height, min_x, max_x, min_y, max_y
    #print "Testing", len(edge_angles), "possible rotations for bounding box... \n"
    pRots = len(edge_angles)
    for i in range( len(edge_angles) ):

        # Create rotation matrix to shift points to baseline
        # R = [ cos(theta)      , cos(theta-PI/2)
        #       cos(theta+PI/2) , cos(theta)     ]
        R = np.array([ [ math.cos(edge_angles[i]), math.cos(edge_angles[i]-(math.pi/2)) ], [ math.cos(edge_angles[i]+(math.pi/2)), math.cos(edge_angles[i]) ] ])
        #print "Rotation matrix for ", edge_angles[i], " is \n", R

        # Apply this rotation to convex hull points
        rot_points = np.dot(R, np.transpose(hull_points_2d) ) # 2x2 * 2xn
        #print "Rotated hull points are \n", rot_points

        # Find min/max x,y points
        min_x = np.nanmin(rot_points[0], axis=0)
        max_x = np.nanmax(rot_points[0], axis=0)
        min_y = np.nanmin(rot_points[1], axis=0)
        max_y = np.nanmax(rot_points[1], axis=0)
        #print "Min x:", min_x, " Max x: ", max_x, "   Min y:", min_y, " Max y: ", max_y

        # Calculate height/width/area of this bounding rectangle
        width = max_x - min_x
        height = max_y - min_y
        area = width*height
        #print "Potential bounding box ", i, ":  width: ", width, " height: ", height, "  area: ", area 

        # Store the smallest rect found first (a simple convex hull might have 2 answers with same area)
        if (area < min_bbox[1]):
            min_bbox = ( edge_angles[i], area, width, height, min_x, max_x, min_y, max_y )
        # Bypass, return the last found rect
        #min_bbox = ( edge_angles[i], area, width, height, min_x, max_x, min_y, max_y )

    # Re-create rotation matrix for smallest rect
    angle = min_bbox[0]   
    R = np.array([ [ math.cos(angle), math.cos(angle-(math.pi/2)) ], [ math.cos(angle+(math.pi/2)), math.cos(angle) ] ])
    #print "Projection matrix: \n", R

    # Project convex hull points onto rotated frame
    proj_points = np.dot(R, np.transpose(hull_points_2d) ) # 2x2 * 2xn
    #print "Project hull points are \n", proj_points

    # min/max x,y points are against baseline
    min_x = min_bbox[4]
    max_x = min_bbox[5]
    min_y = min_bbox[6]
    max_y = min_bbox[7]
    #print "Min x:", min_x, " Max x: ", max_x, "   Min y:", min_y, " Max y: ", max_y

    # Calculate center point and project onto rotated frame
    center_x = (min_x + max_x)/2
    center_y = (min_y + max_y)/2
    center_point = np.dot( [ center_x, center_y ], R )
    #print "Bounding box center point: \n", center_point

    # Calculate corner points and project onto rotated frame
    corner_points = np.zeros( (4,2) ) # empty 2 column array
    corner_points[0] = np.dot( [ max_x, min_y ], R )
    corner_points[1] = np.dot( [ min_x, min_y ], R )
    corner_points[2] = np.dot( [ min_x, max_y ], R )
    corner_points[3] = np.dot( [ max_x, max_y ], R )
    #print "Bounding box corner points: \n", corner_points

    #print "Angle of rotation: ", angle, "rad  ", angle * (180/math.pi), "deg"

    return (angle, min_bbox[1], min_bbox[2], min_bbox[3], center_point, corner_points, pRots) # rot_angle, area, width, height, center_point, corner_points
      
#------------------------------------------
def sliver(fc, guardar=True):
#------------------------------------------
    lista = coordenadas(fc)
    candidatos = procSli(fc, minArea)
    cfinal = "".join(str(x)+"," for x in candidatos)
    cfinal = cfinal[:len(cfinal)-1]
        

    expresionA = arcpy.AddFieldDelimiters(fc, "SHAPE_Area")
    expresionB = arcpy.AddFieldDelimiters(fc, "SHAPE_Length")
    expresion = expresionA + " < "+ minArea+" or ("+expresionA +"/"+expresionB+") < 0.25"
    expresion = "OBJECTID IN ("+cfinal+")"
    if eco:
      imprimir("Expresion="+expresion)
    seleccion ="sliver"
    if eco:
       imprimir("\nETAPA   ==> ELIMINAR SLIVERS\n"+fc+"\nSliver Condition="+expresion)
    arcpy.MakeFeatureLayer_management(fc, seleccion)
    arcpy.SelectLayerByAttribute_management(seleccion,"NEW_SELECTION", expresion)
    aEliminar = int(arcpy.GetCount_management(seleccion).getOutput(0))
    if arcpy.Exists(fc+"_S"):
       arcpy.Delete_management(fc+"_S")
    if aEliminar>0:
        if eco:
           imprimir("Eliminado Slivers...."+str(aEliminar))
        if guardar:
          if eco:
            imprimir("COPIANDO "+seleccion+"==>"+fc+"_S workspace="+arcpy.env.workspace)
          arcpy.CopyFeatures_management(seleccion, fc+"_S")
        arcpy.DeleteFeatures_management(seleccion)
    else:
      imprimir("\n================================\nNO SE ENCONTRARON SLIVER PARA :"+fc)
      
  

    
#---------------------------        
def procesar():
#---------------------------
    global elDict
    arcpy.env.overwriteOutput = True
    avance = etapa1(cartografia,cws + os.path.sep + actas, cfecha, intersect)
    if eco:
      imprimir("\n==================\nCREANDO NO PLANIF & REMANTE DE "+avance)
    crearSalidas(avance, NoPlanif, Remanente)
    union = "union"
    funion = scr + os.path.sep + union

    fcarto = cws + os.path.sep + cartografia
    if not arcpy.Exists(fcarto):
        imprimir("PROBLEMAS CARTO="+cartografia+ " no existe")
        return
    factas = cws + os.path.sep + actas
    if not arcpy.Exists(factas):
        imprimir("PROBLEMAS ACTAS="+actas+ " no existe")
        return
    
        
    arcpy.Union_analysis([[fcarto,1],[factas,2]],funion,"all", eps)
    if eco:
      imprimir("\n================\nAGREGAR CAMPOS CON "+funion+" fecha ="+cfecha)
      imprimir('UNION ='+funion + " UNION ENTRE "+fcarto+" y "+factas)
    agregarCampos(funion, cfecha)
    
    noPlanificados = arcpy.AddFieldDelimiters(funion,"FID_"+actas)+ " =-1"
    Remanentes     = arcpy.AddFieldDelimiters(funion,"FID_"+cartografia)+"=-1"
    seleccion = "seleccion"
    arcpy.MakeFeatureLayer_management(funion, seleccion)
    arcpy.SelectLayerByAttribute_management(seleccion,"NEW_SELECTION",noPlanificados)
    if eco:
         imprimir("Agregando "+ funion +" a "+NoPlanif)
    arcpy.Append_management(seleccion, scr+os.path.sep+ NoPlanif, schema_type='NO_TEST')

    arcpy.SelectLayerByAttribute_management(seleccion,"NEW_SELECTION",Remanentes)
    arcpy.Append_management(seleccion, scr+os.path.sep+ Remanente,"NO_TEST")

    singlePart(NoPlanif)
    singlePart(Remanente)
    
    if eliminarSliver:
        if eco:
            imprimir("\nEliminando Slivers en "+NoPlanif+","+Remanente+","+intersect)
            
        sliver( scr+os.path.sep+NoPlanif)
        sliver (scr+os.path.sep+Remanente)
        sliver (scr+os.path.sep+intersect)
    # explode los remanantes
    #if eco:
    #    imprimir("MULTIPART TO SINGLE PART...")
    
    #if arcpy.Exists(Remanente+"1"):
    #     arcpy.Delete_management(Remanente+"1")
    #arcpy.MultipartToSinglepart_management(Remanente, Remanente+"1")
    #if arcpy.Exists(Remanente):
    #    arcpy.Delete_management(Remanente)
    #if arcpy.Exists(Remanente):
    #    arcpy.Delete_management(Remanente)   
    #arcpy.Rename_management(Remanente + "1", Remanente)
    agregRemanente(Remanente)
    arcpy.CalculateField_management(Remanente,"PCT_AVANCE","100 - CLNG([shape_area] / [AREA_1])/100")
    # ahora la parte global
    avanceDi=procesarAvance(actas)
    imprimir("Procesando Excel="+archivoE)
    diccionario = leerExcel(archivoE)
    elDict=diccionario
    if eco:
      imprimir("------------------")
      imprimir(len(elDict))
      imprimir("------------------")
    cerrarCos(avanceDi, diccionario, camposCierre)
    imprimir("Cargando capas.....")
    resumen(avanceDi)
#-------------------------------
def singlePart(fc):
#-------------------------------
    if eco:
      imprimir("SINGLE PART ==> "+fc)
    if arcpy.Exists(fc+"1"):
         arcpy.Delete_management(fc+"1")
    arcpy.MultipartToSinglepart_management(fc, fc+"1")
    if arcpy.Exists(fc):
        arcpy.Delete_management(fc)
    if arcpy.Exists(fc):
        arcpy.Delete_management(fc)   
    arcpy.Rename_management(fc + "1", fc)
    
#---------------------------------
def procesaNO(fc, dicc, campos, mas=""):
#---------------------------------
     if eco:
          imprimir("Agregando campos a "+fc)
     agregCosFinal(fc, campos, False)
     if eco:
          imprimir("Cerrando Actas en "+fc)
     cerrarCos(fc, dicc, campos, False,mas)
     if eco:
          imprimir("FIN PROCESANO "+fc)
     
#---------------------------------
def cerrarCos(fc, dicc, campos, todo=True, mas=""):
#---------------------------------
     if eco:
          imprimir("CerrarCos con "+fc+ " "+str(todo))
     fields = [sCampos[0][0]+"_1"]
     if not todo:
          fields=[sCampos[0][0]+mas]
          fields.append(campos[0][0])
     else:
       for a in campos:
              fields.append(a[0])
     #imprimir(fields)
     #imprimir(fc)
     #cx = [f.name for f in arcpy.ListFields(fc)]
     #imprimir(cx)
     tipo = "TIPO"
     if todo:
       arcpy.SetSubtypeField_management (fc, tipo)
       arcpy.AddSubtype_management (fc, 0, "ACTIVA")
       arcpy.AddSubtype_management (fc, 1, "CERRADA")

     if eco:
       imprimir("UPDATE PARA "+fc)
     with arcpy.da.UpdateCursor(fc, fields) as cursor:
          if eco:
               imprimir("Loop DA cursor ")
               imprimir(fc)
               imprimir(fields)
          for fila in cursor:
            try:

               fila[1] = 'N'
               if todo:
                    fila[6] = 0
               acta = long(fila[0])
               if eco:
                 imprimir(acta)
                 kk=dicc.get(acta)
                 imprimir(len(dicc))
               #imprimir(acta)
               if dicc.get(acta) <> None:
                    b = dicc.get(acta)
                    #imprimir(b)
                    fila[1]='S'
                    if todo:
                       bb = -1
                       if b[3] <> "":
                         bb = long(b[3])
                       fila[2]= bb
                       fila[3]= b[4]
                       fila[4]= b[1]
                       fila[5]= b[2]
                       fila[6]= 1
               cursor.updateRow(fila)
            except:
                 pass
     del cursor
     if eco:
          imprimir("Fin CerrarCos")
                    
#---------------------------------
def partir(fc):
#---------------------------------
    salida = fc
    if arcpy.Exists(fc):
        d = arcpy.Describe(fc)
        return d.baseName
    else:
        pass
    return salida

    
    
if __name__ == '__main__':    
    cws         = arcpy.GetParameterAsText(0)
    cartografia = arcpy.GetParameterAsText(1)
    actas       = arcpy.GetParameterAsText(2)
    minAre      = arcpy.GetParameterAsText(3)
    archivoE    = arcpy.GetParameterAsText(4)
    
    if cws =='#' or not cws:
       cws = cwDefecto
       if not arcpy.Exists(cws):
           imprimir("WORKSPACE CON CARTOGRAFIA & ACTAS ES OBLIGATORIO")
           sys.exit()
    
    arcpy.env.workspace = cws
    cartografia = partir(cartografia)
    actas       = partir(actas)
     
    if not os.path.isdir(tmpDir):                              # SI NO EXISTE SE CREA DIR TEMPORAL C:\TEMP
           os.mkdir(tmpDir)

    if not arcpy.Exists(tmpDir + os.path.sep + "actas.gdb"):   # SI NO EXISTE SE CREA ACTAS.GDB
       arcpy.CreateFileGDB_management(tmpDir, "actas")
    scr = tmpDir + os.path.sep + "actas.gdb"
    

    if cartografia == "#" or not cartografia:
        cartografia = cDefecto
        
    if not arcpy.Exists(cws + os.path.sep + cartografia):
        imprimir("COSECHA CARTOFRAFICA =" + cartografia + " no existe("+cws+")")
        sys.exit()
    else:
         c1 = [f.name for f in arcpy.ListFields(cartografia)]
         if cfecha not in c1:
             imprimir("COSECHA CARTOGRAFICA SIN CAMPO FECHA="+cfecha)
             sys.exit()
         if has not in c1:
             imprimir("COSECHA CARTOGRAFICA SIN CAMPO "+ has)
             sys.exit()        
    if actas == "#" or not actas:
        actas = aDefecto
        
    if not arcpy.Exists(cws + os.path.sep + actas):
        imprimir("COSECHA PLANIFICADA =" + actas + " no existe("+cws+")")
        sys.exit()
    else:
        c2 = [f.name for f in arcpy.ListFields(actas)]
        if has not in c2:
             imprimir("COSECHA PLANIFICADA SIN CAMPO "+has)
             sys.exit()
    if minAre =="#" or not minAre:
        minAre = minArea

    minArea = minAre

    # RECALCULAR LAS HAS
    agregarHAS(cartografia, has)
    agregarHAS(actas, has)
    if eco:
        imprimir("COMENZANDO....")
        imprimir("ESPACIO DE TRABAJO   = "+cws)
        imprimir("COSECHA CARTOGRAFICA = "+cartografia)
        imprimir("COSECHA PLANIFICADA  = "+actas)
        imprimir("SCRATCH DE TRABAJO   = "+scr)

    procesar()
    limpiaFinal()
    arcpy.env.workspace = cws
        

def listaPuntos(poligono):
  salida =[]
  for feature in poligono:
    for linea in feature:
      for punto in linea:
          salida.append((punto.X,punto.Y))
  return salida

